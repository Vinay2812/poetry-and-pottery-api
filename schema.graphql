# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

input AddToCartInput {
  product_id: Int!
  quantity: Int = 1
}

type CancelRegistrationResponse {
  error: String
  success: Boolean!
}

type CartItem {
  created_at: DateTime!
  id: Int!
  product: ProductBase!
  product_id: Int!
  quantity: Int!
  updated_at: DateTime!
  user_id: Int!
}

type CartMutationResponse {
  item: CartItem
  success: Boolean!
}

type CartResponse {
  items: [CartItem!]!
  subtotal: Int!
  total: Int!
}

input CreateEventReviewInput {
  eventId: String!
  imageUrls: [String!]
  rating: Int!
  review: String
}

input CreateOrderInput {
  shippingAddress: ShippingAddressInput!
  shippingFee: Int!
}

input CreateProductReviewInput {
  imageUrls: [String!]
  productId: Int!
  rating: Int!
  review: String
}

type CreateReviewResponse {
  error: String
  review: Review
  success: Boolean!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

type DeleteReviewResponse {
  error: String
  success: Boolean!
}

type EventBase {
  available_seats: Int!
  avg_rating: Float
  created_at: DateTime!
  description: String!
  ends_at: DateTime!
  full_location: String!
  gallery: [String!]!
  highlights: [String!]!
  id: String!
  image: String!
  includes: [String!]!
  instructor: String!
  level: EventLevel!
  location: String!
  price: Int!
  registrations_count: Int!
  reviews_count: Int!
  slug: String!
  starts_at: DateTime!
  status: EventStatus!
  title: String!
  total_seats: Int!
  updated_at: DateTime!
}

type EventDetail {
  available_seats: Int!
  avg_rating: Float
  created_at: DateTime!
  description: String!
  ends_at: DateTime!
  full_location: String!
  gallery: [String!]!
  highlights: [String!]!
  id: String!
  image: String!
  includes: [String!]!
  instructor: String!
  is_registered: Boolean!
  level: EventLevel!
  location: String!
  price: Int!
  registrations_count: Int!
  reviews: [EventReview!]!
  reviews_count: Int!
  slug: String!
  starts_at: DateTime!
  status: EventStatus!
  title: String!
  total_seats: Int!
  updated_at: DateTime!
}

"""The difficulty level of an event"""
enum EventLevel {
  ADVANCED
  BEGINNER
  INTERMEDIATE
}

type EventRegistration {
  approved_at: DateTime
  cancelled_at: DateTime
  confirmed_at: DateTime
  created_at: DateTime!
  discount: Int!
  event: RegistrationEvent!
  event_id: String!
  has_reviewed: Boolean!
  id: String!
  paid_at: DateTime
  price: Int!
  request_at: DateTime
  seats_reserved: Int!
  status: EventRegistrationStatus!
  updated_at: DateTime!
  user: RegistrationUser!
  user_id: Int!
}

"""The status of an event registration"""
enum EventRegistrationStatus {
  APPROVED
  CANCELLED
  CONFIRMED
  PAID
  PENDING
  REJECTED
}

type EventReview {
  created_at: DateTime!
  event_id: String
  id: Int!
  image_urls: [String!]!
  likes: [EventReviewLike!]!
  rating: Int!
  review: String
  updated_at: DateTime!
  user: EventReviewUser!
  user_id: Int!
}

type EventReviewLike {
  id: Int!
  review_id: Int!
  user_id: Int!
}

type EventReviewUser {
  email: String!
  id: Int!
  image: String
  name: String
}

"""The status of an event"""
enum EventStatus {
  ACTIVE
  CANCELLED
  COMPLETED
  INACTIVE
  UPCOMING
}

type EventWithUserContext {
  current_user_id: Int
  event: EventDetail!
  is_past_event: Boolean!
  registration: EventRegistration
}

input EventsFilterInput {
  level: EventLevel
  limit: Int = 12
  page: Int = 1
  search: String
  status: EventStatus
}

type EventsResponse {
  data: [EventBase!]!
  levels: [EventLevel!]!
  page: Int!
  total: Int!
  total_pages: Int!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Mutation {
  addToCart(input: AddToCartInput!): CartMutationResponse!
  addToWishlist(productId: Int!): WishlistMutationResponse!
  cancelOrder(orderId: String!): OrderMutationResponse!
  cancelRegistration(registrationId: String!): CancelRegistrationResponse!
  clearCart: Boolean!
  createEventReview(input: CreateEventReviewInput!): CreateReviewResponse!
  createOrder(input: CreateOrderInput!): OrderMutationResponse!
  createProductReview(input: CreateProductReviewInput!): CreateReviewResponse!
  deleteReview(reviewId: Int!): DeleteReviewResponse!
  moveToCart(productId: Int!): Boolean!
  registerForEvent(input: RegisterForEventInput!): RegisterForEventResponse!
  removeFromCart(productId: Int!): Boolean!
  removeFromWishlist(productId: Int!): Boolean!
  toggleReviewLike(reviewId: Int!): ToggleReviewLikeResponse!
  toggleWishlist(productId: Int!): ToggleWishlistResponse!
  updateCartQuantity(input: UpdateCartQuantityInput!): CartMutationResponse!
}

type Order {
  approved_at: DateTime
  cancelled_at: DateTime
  created_at: DateTime!
  delivered_at: DateTime
  discount: Int!
  id: String!
  ordered_products: [OrderItem!]!
  paid_at: DateTime
  refunded_at: DateTime
  request_at: DateTime
  returned_at: DateTime
  shipped_at: DateTime
  shipping_address: JSON!
  shipping_fee: Int!
  status: OrderStatus!
  subtotal: Int!
  total: Int!
  updated_at: DateTime!
  user: OrderUser!
  user_id: Int!
}

type OrderItem {
  created_at: DateTime!
  discount: Int!
  has_reviewed: Boolean!
  id: Int!
  order_id: String!
  price: Int!
  product: ProductBase!
  product_id: Int!
  quantity: Int!
  updated_at: DateTime!
}

type OrderMutationResponse {
  error: String
  order: Order
  success: Boolean!
}

"""The status of an order"""
enum OrderStatus {
  CANCELLED
  DELIVERED
  PAID
  PENDING
  PROCESSING
  REFUNDED
  RETURNED
  SHIPPED
}

type OrderUser {
  email: String!
  id: Int!
  name: String
}

input OrdersFilterInput {
  limit: Int = 10
  page: Int = 1
  search: String
}

type OrdersResponse {
  data: [Order!]!
  page: Int!
  total: Int!
  total_pages: Int!
}

type PriceHistogramBucket {
  count: Int!
  max: Int!
  min: Int!
}

type PriceRange {
  max: Int!
  min: Int!
}

type ProductBase {
  available_quantity: Int!
  avg_rating: Int!
  color_code: String!
  color_name: String!
  id: Int!
  image_urls: [String!]!
  in_wishlist: Boolean!
  material: String!
  name: String!
  price: Int!
  reviews_count: Int!
  slug: String!
  total_quantity: Int!
}

type ProductDetail {
  available_quantity: Int!
  avg_rating: Int!
  categories: [String!]!
  color_code: String!
  color_name: String!
  created_at: DateTime!
  description: String
  id: Int!
  image_urls: [String!]!
  in_wishlist: Boolean!
  instructions: [String!]!
  is_active: Boolean!
  material: String!
  name: String!
  price: Int!
  reviews: [ProductReview!]!
  reviews_count: Int!
  slug: String!
  total_quantity: Int!
  updated_at: DateTime!
}

"""The order by which the products should be sorted"""
enum ProductOrderBy {
  FEATURED
  NEW
  PRICE_HIGH_TO_LOW
  PRICE_LOW_TO_HIGH
  RATING_HIGH_TO_LOW
  RATING_LOW_TO_HIGH
}

type ProductReview {
  created_at: DateTime!
  id: Int!
  image_urls: [String!]!
  likes: [ReviewLike!]!
  rating: Int!
  review: String
  user: ReviewUser
  user_id: Int!
}

type ProductsFilter {
  categories: [String!]
  limit: Int
  materials: [String!]
  max_price: Int
  min_price: Int
  order_by: ProductOrderBy
  page: Int
  search: String
}

input ProductsFilterInput {
  categories: [String!]
  limit: Int
  materials: [String!]
  max_price: Int
  min_price: Int
  order_by: ProductOrderBy
  page: Int
  search: String
}

type ProductsMeta {
  categories: [String!]!
  materials: [String!]!
  price_histogram: [PriceHistogramBucket!]!
  price_range: PriceRange!
}

type ProductsResponse {
  filter: ProductsFilter!
  meta: ProductsMeta!
  products: [ProductBase!]!
  total_pages: Int!
  total_products: Int!
}

type Query {
  bestSellers(limit: Int): [ProductBase!]!
  cart: CartResponse!
  categories: [String!]!
  completedRegistrations(filter: RegistrationsFilterInput): RegistrationsResponse!
  eventById(id: String!): EventDetail
  eventBySlug(slug: String!): EventDetail
  eventReviews(eventId: String!, filter: ReviewsFilterInput): ReviewsResponse!
  eventWithUserContext(eventId: String!): EventWithUserContext
  events(filter: EventsFilterInput): EventsResponse!
  featuredProducts(limit: Int): [ProductBase!]!
  materials: [String!]!
  order(id: String!): Order
  orders(filter: OrdersFilterInput): OrdersResponse!
  pastEvents(filter: EventsFilterInput): EventsResponse!
  productById(id: Int!): ProductDetail
  productBySlug(slug: String!): ProductDetail
  productReviews(filter: ReviewsFilterInput, productId: Int!): ReviewsResponse!
  products(filter: ProductsFilterInput!): ProductsResponse!
  recommendedProducts(limit: Int): [ProductBase!]!
  registrationById(registrationId: String!): EventRegistration
  relatedProducts(limit: Int, productId: Int!): [ProductBase!]!
  upcomingEvents(filter: EventsFilterInput): EventsResponse!
  upcomingRegistrations(filter: RegistrationsFilterInput): RegistrationsResponse!
  user: UserResponse!
  userCounts: UserCounts!
  userRegistrations(filter: RegistrationsFilterInput): RegistrationsResponse!
  wishlist(filter: WishlistFilterInput): WishlistResponse!
  wishlistIds: [Int!]!
}

input RegisterForEventInput {
  eventId: String!
  seats: Int = 1
}

type RegisterForEventResponse {
  error: String
  registration: EventRegistration
  success: Boolean!
}

type RegistrationEvent {
  available_seats: Int!
  created_at: DateTime!
  description: String!
  ends_at: DateTime!
  full_location: String!
  gallery: [String!]!
  highlights: [String!]!
  id: String!
  image: String!
  includes: [String!]!
  instructor: String!
  level: EventLevel!
  location: String!
  price: Int!
  slug: String!
  starts_at: DateTime!
  status: EventStatus!
  title: String!
  total_seats: Int!
  updated_at: DateTime!
}

type RegistrationUser {
  email: String!
  id: Int!
  image: String
  name: String
}

input RegistrationsFilterInput {
  limit: Int = 12
  page: Int = 1
  search: String
}

type RegistrationsResponse {
  data: [EventRegistration!]!
  page: Int!
  total: Int!
  total_pages: Int!
}

type Review {
  created_at: DateTime!
  event_id: String
  id: Int!
  image_urls: [String!]!
  is_liked_by_current_user: Boolean!
  likes: [ReviewLike!]!
  likes_count: Int!
  product_id: Int
  rating: Int!
  review: String
  updated_at: DateTime!
  user: ReviewUser!
  user_id: Int!
}

type ReviewLike {
  id: Int!
  user_id: Int!
}

type ReviewUser {
  id: Int!
  image: String
  name: String
}

input ReviewsFilterInput {
  limit: Int = 10
  page: Int = 1
}

type ReviewsResponse {
  data: [Review!]!
  page: Int!
  total: Int!
  total_pages: Int!
}

input ShippingAddressInput {
  addressLine1: String!
  addressLine2: String
  city: String!
  contactNumber: String
  name: String!
  state: String!
  zip: String!
}

"""The action performed when toggling wishlist"""
enum ToggleAction {
  ADDED
  REMOVED
}

"""The action taken when toggling a review like"""
enum ToggleLikeAction {
  LIKED
  UNLIKED
}

type ToggleReviewLikeResponse {
  action: ToggleLikeAction
  error: String
  likes_count: Int
  success: Boolean!
}

type ToggleWishlistResponse {
  action: ToggleAction!
  item: WishlistItem
  success: Boolean!
}

input UpdateCartQuantityInput {
  product_id: Int!
  quantity: Int!
}

type UserCounts {
  cartCount: Int!
  eventRegistrationsCount: Int!
  pendingOrdersCount: Int!
  wishlistCount: Int!
}

type UserResponse {
  auth_id: String!
  email: String!
  id: Int!
  image: String
  name: String
  phone: String
  role: UserRole!
  subscribed_to_newsletter: Boolean!
}

"""Defines the role of the user"""
enum UserRole {
  ADMIN
  USER
}

input WishlistFilterInput {
  limit: Int = 12
  page: Int = 1
}

type WishlistItem {
  created_at: DateTime!
  id: Int!
  product: ProductBase!
  product_id: Int!
  updated_at: DateTime!
  user_id: Int!
}

type WishlistMutationResponse {
  item: WishlistItem
  success: Boolean!
}

type WishlistResponse {
  data: [WishlistItem!]!
  page: Int!
  total: Int!
  total_pages: Int!
}